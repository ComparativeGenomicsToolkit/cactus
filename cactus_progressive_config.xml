<!-- This XML tree contains the parameters to cactus_progressive.py -->
<!-- The distanceToAddToRootAlignment parameter is how much extra divergence distance to allow when aligning children of the root genome -->
<cactusWorkflowConfig distanceToAddToRootAlignment="0.1">
	<constants defaultMemory="mediumMemory" defaultOverlargeMemory="mediumMemory" defaultCpu="1" defaultOverlargeCpu="1">
		<!-- These constants are used to control the amount of memory and cpu the different jobs in a batch are using. -->
  		<defines littleMemory="200000000" mediumMemory="500000000" bigMemory="2000000000" maxFlowerGroupSizeRecursion="100000000"/>
  		<!-- These constants are used to control parameters that depend on phylogenetic distance. Setting
  		     useDefault to 0 will force it to use the default divergence controlled parameter -->
  		<divergences useDefault="0" one="0.1" two="0.15" three="0.2" four="0.25" five="0.35"/>
	</constants>
	<!-- The preprocessor tags are used to modify/check the input sequences before alignment -->
	<!-- The first preprocessor tag checks that the first word of every fasta header is unique, as this is required for HAL. It throws errors if this is not the case -->
	<!-- The checkAssemblyHub option (if enabled) ensures that the first word contains only alphanumeric or '_', '-', ':', or '.' characters, and is unique. If you don't intend to make an assembly hub, you can turn off this option here. -->
	<preprocessor check="1" memory="littleMemory" preprocessorString="cactus_checkUniqueHeaders.py --checkAssemblyHub IN_FILE"/>
	<!-- The preprocessor for cactus_lastzRepeatMask masks every seed that is part of more than XX other alignments, this stops a combinatorial explosion in pairwise alignments -->
	<preprocessor chunkSize="3000000" proportionToSample="0.2" memory="littleMemory" preprocessorString="cactus_lastzRepeatMask.py --proportionSampled=PROPORTION_SAMPLED --tempDir=TEMP_DIR --minPeriod=50 --lastzOpts='--step=3 --ambiguous=iupac,100,100 --ungapped --queryhsplimit=keep,nowarn:1500' IN_FILE OUT_FILE "/>
        <!-- Options for trimming ingroups & outgroups using the trim strategy -->
        <!-- Ingroup trim options: -->
        <!-- trimFlanking: The length of flanking sequence to attach
             to the trimmed ingroup sequences -->
        <!-- trimMinSize: The minimum size of uncovered regions
             (*before* adding flanking sequence) to output from the
             trimming process -->
        <!-- trimThreshold: The minimum fraction of bases in a window
             that must have coverage >= 1 for it to be considered
             "covered" and be trimmed away and not be aligned against
             the next outgroup -->
        <!-- trimWindowSize: The size of the window to integrate
             coverage over -->
        <!-- Outgroup trim options: -->
        <!-- trimOutgroupFlanking: The amount of flanking sequence to
             leave on the ends of the trimmed outgroup fragments. NB:
             this value must be larger than the
             'splitIndelsLongerThanThis' value in the realign
             arguments -->
    <trimBlast doTrimStrategy="1"
               trimFlanking="10"
               trimMinSize="100"
               trimThreshold="1.0"
               trimWindowSize="1"
               trimOutgroupFlanking="2000"
    >
    </trimBlast>

	<ktserver memory="mediumMemory"/>
	<setup makeEventHeadersAlphaNumeric="0"/>
	<!-- The caf tag contains parameters for the caf algorithm. -->
	<!-- Increase the chunkSize in the caf tag to reduce the number of blast jobs approximately quadratically -->
	<caf 
		chunkSize="25000000" 
		realign="1"
		realignArguments="--gapGamma 0.9 --diagonalExpansion 4 --splitMatrixBiggerThanThis 10 --constraintDiagonalTrim 0 --alignAmbiguityCharacters --splitIndelsLongerThanThis 99"
		compressFiles="1" 
		overlapSize="10000" 
		filterByIdentity="1" 
		identityRatio="3" 
		minimumDistance="0.01" 
		minimumSequenceLengthForBlast="30"
		annealingRounds="128" 
		deannealingRounds="2 8" 
		blockTrim="5" 
		minimumTreeCoverage="0.0" 
		trim="0 0" 
		minimumBlockDegree="2"
		minimumIngroupDegree="1"
		minimumOutgroupDegree="0"
                minimumNumberOfSpecies="1"
		singleCopyIngroup="0"
		singleCopyOutgroup="relaxed"
		maxAdjacencyComponentSizeRatio="50"
		minLengthForChromosome="1000000"
		proportionOfUnalignedBasesForNewChromosome="0.8"
		maximumMedianSequenceLengthBetweenLinkedEnds="1000"
		lastzMemory="littleMemory"
                removeRecoverableChains="unequalNumberOfIngroupCopiesOrNoOutgroup"
                maxRecoverableChainsIterations="5"
                maxRecoverableChainLength="500000"
	>
		<!-- The following are parametrised to produce the same results as the default settings, 
		within a margin of 0.2% sensitivity, should be very fast for close genomes, these were tuned using the blast/blastParametersScript.py
		We could go even faster for less than 0.05 divergence using, but want to be robust to poor branch length estimates -->
		<divergence 
			argName="lastzArguments"
		 	one="--step=2 --ambiguous=iupac,100,100 --ydrop=3000 --notransition"
		 	two="--step=5 --ambiguous=iupac,100,100 --ydrop=3000"
		 	three="--step=4 --ambiguous=iupac,100,100 --ydrop=3000"
		 	four="--step=3 --ambiguous=iupac,100,100 --ydrop=3000"
		 	five="--step=2 --ambiguous=iupac,100,100 --ydrop=3000"
		 	default="--step=1 --ambiguous=iupac,100,100 --ydrop=3000"
		 />
		<CactusCafRecursion maxFlowerGroupSize="100000000"/>
		<CactusCafWrapper minFlowerSize="1" maxFlowerGroupSize="25000000"/>
		<CactusCafWrapperLarge2 overlargeMemory="bigMemory"/>
	</caf>
	<!-- The caf tag contains parameters for the bar algorithm. -->
	<!-- The veryLargeEndSize parameter determines how big an end needs to be (in terms of bases in sequences incident with the end)
	for the end to be aligned on its own. -->
	<bar
		runBar="1"
		spanningTrees="5" 
		gapGamma="0.2" 
		useBanding="1" 
		bandingLimit="1000000" 
		splitMatrixBiggerThanThis="3000" 
        anchorMatrixBiggerThanThis="500"
        repeatMaskMatrixBiggerThanThis="500"
		diagonalExpansion="20"
		constraintDiagonalTrim="14" 
		minimumBlockDegree="2" 
		minimumIngroupDegree="1"
		minimumOutgroupDegree="0"
                minimumNumberOfSpecies="1"
		alignAmbiguityCharacters="1"
		largeEndSize="5000"
		veryLargeEndSize="2000000"
		maximumNumberOfSequencesBeforeSwitchingToFast="10"
		pruneOutStubAlignments="1"
	>
		<CactusBarRecursion maxFlowerGroupSize="maxFlowerGroupSizeRecursion"/>
		<!-- The maxFlowerGroupSize in cactusBarWrapper determines how many bases to allow in one "small" job which will be run using the "littleMemory" -->
		<CactusBarWrapper maxFlowerGroupSize="2000000" memory="littleMemory"/>
		<!-- The maxFlowerGroupSize in cactusBarWrapperLarge determines how many of each large broken up to allow in one "small" job which will be run using the "littleMemory" -->
		<CactusBarWrapperLarge maxFlowerGroupSize="2000000"/>
		<CactusBarEndAlignerWrapper memory="littleMemory"/>
	</bar>
	<!-- The normal tag provides parameters to the cactus_normalisation script, which "normalises" a cactus to make all chains of maximal length. This is not used much now. -->
	<normal 
		iterations="0"
	>
		<CactusNormalRecursion maxFlowerGroupSize="maxFlowerGroupSizeRecursion" maxFlowerWrapperGroupSize="10000000"/>
		<CactusNormalWrapper/>
	</normal>
	<!-- The avg tag is for a prototype algorithm, currently just builds trees. Not currently compatible with cactus_progressive -->
	<avg
		buildAvgs="0"
	>
		<CactusAVGRecursion maxFlowerGroupSize="maxFlowerGroupSizeRecursion" maxFlowerWrapperGroupSize="10000000"/>
		<CactusAVGWrapper/>
	</avg>
	<!-- The reference tag provides parameters to cactus_reference, a method used to construct a reference genome for a given cactus database. -->
	<!-- numberOfNs is the number of Ns to insert into an ancestral sequence when an adjacency is uncertain, think of its as the Ns in a scaffold gap -->
	<!-- minNumberOfSequencesToSupportAdjacency is the number of sequences needed to bridge an adjacency -->
	<!-- makeScaffolds is a boolean that enables the bridging of uncertain adjacencies in an ancestral sequence providing the larger scale problem (parent flower in cactus), bridges the path. -->
	<reference 
		buildReference="1"
		matchingAlgorithm="blossom5" 
		reference="reference" 
		useSimulatedAnnealing="1" 
		theta="0.0001"        
		maxWalkForCalculatingZ="100000" 
		permutations="10"
		ignoreUnalignedGaps="1"
		wiggle="0.9999"
		numberOfNs="10"
		minNumberOfSequencesToSupportAdjacency="1"
		makeScaffolds="1"
	>
		<CactusReferenceRecursion maxFlowerGroupSize="maxFlowerGroupSizeRecursion" maxFlowerWrapperGroupSize="50000000"/>
	 	<CactusReferenceWrapper/>
	 	<CactusSetReferenceCoordinatesUpWrapper/>
	 	<CactusSetReferenceCoordinatesDownRecursion maxFlowerGroupSize="maxFlowerGroupSizeRecursion" maxFlowerWrapperGroupSize="50000000"/>
	 	<CactusSetReferenceCoordinatesDownWrapper/>
	</reference>
	<!-- The check tag provides parameters to cactus_check, a script which checks that a constructed cactus database is as expected. -->
	<check 
		runCheck="0"
	>
		<CactusCheckRecursion maxFlowerGroupSize="maxFlowerGroupSizeRecursion" maxFlowerWrapperGroupSize="50000000"/>
		<CactusCheckWrapper/>
	</check>
	<!-- The hal tag controls the creation of hal and fasta files from the pipeline. -->
	<hal
		buildHal="1"
		buildFasta="1"
	>
		<CactusHalGeneratorRecursion maxFlowerGroupSize="50000000"/>
		<CactusHalGeneratorUpWrapper/>
	</hal>
  	<multi_cactus>
		<outgroup 
			strategy="greedyPreference"
			threshold="0"
			ancestor_quality_fraction="0.75"
                        max_num_outgroups="3"
		/>
	 	<decomposition 
	 		subtree_size="2" 
	 		self_alignment="false" 
	 		default_internal_node_prefix="Anc"
			max_parallel_subtrees="5"
	 	/>
  	</multi_cactus>
    <ProgressiveNext/>
    <ProgressiveUp/>
    <ProgressiveDown/>
    <ProgressiveOut/>
    <RunCactusPreprocessorThenProgressiveDown/>
    <RunCactusPreprocessorThenProgressiveDown2/>
    <exportHal disk="20000000000"/>

</cactusWorkflowConfig>
