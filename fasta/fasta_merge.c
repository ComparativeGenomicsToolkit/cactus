/*
 * fasta_chunk: Break a set of sequence files into a series of overlapping chunks
 * suitable for parallel computation.
 *
 * Released under the MIT license, see LICENSE.txt
 */

/*
 * MERGE POTENTIALLY OVERLAPPING FASTA FILES GENERATED BY
 * fasta_chunk INTO A SINGLE FASTA FILE, reads fasta files from stdin, writes them merged to stdout.
 */

#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <getopt.h>
#include <float.h>
#include <ctype.h>
#include <errno.h>
#include <time.h>

#include "bioioC.h"
#include "commonC.h"

void usage() {
    fprintf(stderr, "fasta_merge [options], version 0.1\n");
    fprintf(stderr, "Merges a series of fasta files, which may contain overlapping sequences, into a single fasta file\n");
    fprintf(stderr, "-i --inputFile : Input file containing names of fasta files to merge. If not specified reads from stdin\n");
    fprintf(stderr, "-o --outputFile : Output fasta file. If not specified outputs to stdout\n");
    fprintf(stderr, "-l --logLevel : Set the log level\n");
    fprintf(stderr, "-h --help : Print this help message\n");
}

FILE *output = NULL; // output
// the trailing overlappig sequence
int64_t p_coordinate = 0;
char *p_seq = NULL;

/* Read fasta sequence from files into the "cur" variables.
 * Then merge into the outputFile (stdout)
 */
static void readFastaCallback(void* destination, const char *fastaHeader, const char *sequence, int64_t length) {
    stList *attributes = fastaDecodeHeader(fastaHeader);
    int64_t offset = atol(stList_peek(attributes));
    assert(offset >= 0);
    if(offset == 0) {
        // print any remaining sequence
        if(p_seq != NULL) {
            fprintf(output, "%s\n", p_seq);
            free(p_seq); // clean up the trailing sequence
        }
        // now print the header for the new sequence
        //free(stList_pop(attributes));
        free(stList_pop(attributes)); // subsequence length
        free(stList_pop(attributes)); // overall sequence length
        char *c = fastaEncodeHeader(attributes);
        fprintf(output, ">%s\n", c);
        free(c);
        // now set the trailing overlapping sequence
        p_coordinate = 0;
        p_seq = stString_copy(sequence);
    }
    else {
        assert(p_seq != NULL);
        assert(p_coordinate <= offset);
        // calculate the split point
        int64_t seq_len = strlen(p_seq);
        assert(p_coordinate + seq_len >= offset); // they must overlap or abut - there can be no gap
        int64_t split_point = (p_coordinate + seq_len + offset)/2; // midpoint
        st_logDebug("Merging at a split point: %" PRIi64 "\n", split_point);
        // check the midpoint is within the bounds of the trailing sequence
        assert(p_coordinate <= split_point);
        assert(split_point >= offset);
        assert(p_coordinate + seq_len >= split_point);
        // print the trailing sequence up to the split point
        char *c = stString_getSubString(p_seq, 0, split_point - p_coordinate);
        fprintf(output, "%s\n", c);
        free(c);
        // now set the trailing overlapping sequence combining the old and new sequences
        c = stString_print("%s", &(sequence[split_point - offset]));
        p_coordinate = split_point;
        free(p_seq);
        p_seq = c;
    }
    stList_destruct(attributes);
}

int main(int argc, char *argv[]) {
    time_t startTime = time(NULL);

    /*
     * Arguments/options
     */
    char *logLevelString = NULL;
    char *inputFile = NULL;
    char *outputFile = NULL;

    ///////////////////////////////////////////////////////////////////////////
    // Parse the inputs
    ///////////////////////////////////////////////////////////////////////////

    while (1) {
        static struct option long_options[] = { { "logLevel", required_argument, 0, 'l' },
                                                { "inputFile", required_argument, 0, 'i' },
                                                { "outputFile", required_argument, 0, 'o' },
                                                { "help", no_argument, 0, 'h' },
                                                { 0, 0, 0, 0 } };

        int option_index = 0;
        int64_t key = getopt_long(argc, argv, "l:i:o:h", long_options, &option_index);
        if (key == -1) {
            break;
        }

        switch (key) {
            case 'l':
                logLevelString = optarg;
                break;
            case 'i':
                inputFile = optarg;
                break;
            case 'o':
                outputFile = optarg;
                break;
            case 'h':
                usage();
                return 0;
            default:
                usage();
                return 1;
        }
    }

    //////////////////////////////////////////////
    //Log the inputs
    //////////////////////////////////////////////

    st_setLogLevelFromString(logLevelString);
    st_logInfo("Input file string : %s\n", inputFile);
    st_logInfo("Output file string : %s\n", outputFile);

    //////////////////////////////////////////////
    // Fasta merging
    //////////////////////////////////////////////

    FILE *input = inputFile == NULL ? stdin : fopen(inputFile, "r");
    output = outputFile == NULL ? stdout : fopen(outputFile, "w");

    char *line = NULL;
    while((line = stFile_getLineFromFile(input)) != NULL) {
        stList *files = stString_split(line);
        for(int64_t i=0; i<stList_length(files); i++) {
            FILE* chunkFile = fopen(stList_get(files, i), "r");
            fastaReadToFunction(chunkFile, NULL, readFastaCallback);
            fclose(chunkFile);
        }
        stList_destruct(files);
        free(line);
    }
    if(p_seq != NULL) { // clean any trailing sequence
        fprintf(output, "%s\n", p_seq);
        free(p_seq); // clean up the trailing sequence
    }

    //////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////

    if(inputFile != NULL) {
        fclose(input);
    }
    if(outputFile != NULL) {
        fclose(output);
    }

    st_logInfo("Fasta merge is done!, %" PRIi64 " seconds have elapsed\n", time(NULL) - startTime);

    //while(1);
    //assert(0);

    return 0;
}
